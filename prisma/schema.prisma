// Kubernetes Policy Hub - Database Schema
// This schema defines the core data models for the Policy Hub SaaS platform

generator client {
  provider = "prisma-client-js"
  binaryTargets = ["native", "linux-musl-arm64-openssl-3.0.x", "linux-musl-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// AUTHENTICATION & MULTI-TENANCY
// ============================================================================

model Organization {
  id        String   @id @default(cuid())
  name      String
  slug      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relationships
  users           User[]
  clusters        Cluster[]
  policies        Policy[]
  policyTemplates PolicyTemplate[]
  simulations     Simulation[]
  apiTokens       ApiToken[]
  packInstallations PolicyPackInstallation[]
  createdPacks      PolicyPack[] @relation("OrgCreatedPacks")
  subscription Subscription?
  invitations  Invitation[]
  auditLogs    AuditLog[]

  @@map("organizations")
}

model User {
  id             String    @id @default(cuid())
  email          String    @unique
  name           String?
  image          String?
  role           UserRole  @default(VIEWER)  // Legacy role field
  newRole        Role      @default(VIEWER)  // New RBAC role
  isSuperAdmin   Boolean   @default(false)   // Platform-level access
  emailVerified  DateTime?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  // Multi-tenancy (optional until onboarding complete)
  organizationId String?
  organization   Organization? @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  // NextAuth relationships
  accounts Account[]
  sessions Session[]

  // Cluster-scoped permissions
  clusterAssignments ClusterAssignment[]

  // Invitations sent by this user
  invitationsSent Invitation[] @relation("InvitedBy")

  // API tokens created by this user
  tokensCreated ApiToken[] @relation("TokenCreator")

  // Audit logs for this user
  auditLogs AuditLog[] @relation("AuditUser")

  // Activity tracking
  policiesCreated      Policy[]     @relation("PolicyCreator")
  simulationsRun       Simulation[] @relation("SimulationRunner")
  deploymentsTriggered PolicyDeployment[] @relation("DeploymentActor")
  packInstallations    PolicyPackInstallation[] @relation("PackInstaller")
  templatesCreated     PolicyTemplate[] @relation("TemplateCreator")
  syncOperations       TemplateSyncOperation[] @relation("SyncTrigger")

  @@map("users")
}

// Legacy role enum - kept for migration compatibility
// New system uses Role enum + isSuperAdmin boolean
enum UserRole {
  ADMIN    // Maps to ORG_ADMIN
  OPERATOR // Maps to POLICY_EDITOR
  VIEWER   // Maps to VIEWER
}

// New RBAC role enum for granular permissions
enum Role {
  ORG_ADMIN       // Manages their organization
  CLUSTER_ADMIN   // Manages assigned clusters (requires ClusterAssignment)
  POLICY_EDITOR   // Edits policies on assigned clusters (requires ClusterAssignment)
  VIEWER          // Read-only access
}

enum TokenType {
  AGENT  // kph_at_ - for operators connecting clusters
  API    // kph_api_ - for automation/CI-CD
}

enum TokenStatus {
  ACTIVE
  REVOKED
}

// NextAuth.js required models
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

// ============================================================================
// RBAC: CLUSTER ASSIGNMENTS & INVITATIONS
// ============================================================================

// Cluster-scoped role assignments (e.g., "Bob is ClusterAdmin for cluster X only")
model ClusterAssignment {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  clusterId String
  cluster   Cluster  @relation(fields: [clusterId], references: [id], onDelete: Cascade)
  role      Role     // CLUSTER_ADMIN, POLICY_EDITOR, or VIEWER
  createdAt DateTime @default(now())

  @@unique([userId, clusterId])
  @@index([clusterId])
  @@map("cluster_assignments")
}

// User invitations (stored in our DB, Clerk handles auth)
model Invitation {
  id             String    @id @default(cuid())
  email          String
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  role           Role      @default(VIEWER)
  invitedById    String
  invitedBy      User      @relation("InvitedBy", fields: [invitedById], references: [id])
  expiresAt      DateTime
  acceptedAt     DateTime?
  createdAt      DateTime  @default(now())

  @@index([email])
  @@index([organizationId])
  @@map("invitations")
}

// System-wide configuration (managed by SuperAdmins)
model SystemConfig {
  key       String   @id
  value     Json
  updatedAt DateTime @updatedAt

  @@map("system_configs")
}

// ============================================================================
// KUBERNETES CLUSTERS
// ============================================================================

model Cluster {
  id          String        @id @default(cuid())
  name        String
  description String?
  provider    CloudProvider
  region      String
  environment Environment   @default(DEVELOPMENT)
  status      ClusterStatus @default(PENDING)

  // Connection details (encrypted in production)
  endpoint    String // Kubernetes API server URL
  caCert      String?  @db.Text // Base64 encoded CA certificate
  authMethod  AuthMethod @default(TOKEN)
  authToken   String?  @db.Text // Service account token (encrypted)
  
  // Operator status
  operatorInstalled Boolean   @default(false)
  operatorVersion   String?
  operatorId        String?   @unique // UUID assigned during operator registration
  lastHeartbeat     DateTime?

  // Metadata
  kubernetesVersion String?
  nodeCount         Int?
  namespaceCount    Int?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Multi-tenancy
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  // Telemetry tracking
  lastTelemetryAt  DateTime?

  // Relationships
  policies            Policy[]
  flowRecords         FlowRecord[]
  simulations         Simulation[]
  apiTokens           ApiToken[]
  flowSummaries       FlowSummary[]
  processSummaries    ProcessSummary[]
  policySimulations   PolicySimulation[]
  notifications       Notification[]
  policyDeployments   PolicyDeployment[]
  validationSummaries ValidationSummary[]
  validationEvents    ValidationEvent[]
  packDeployments              PolicyPackDeployment[]
  processValidationSummaries   ProcessValidationSummary[]
  processValidationEvents      ProcessValidationEvent[]
  clusterAssignments           ClusterAssignment[]
  auditLogs                    AuditLog[]

  @@unique([organizationId, name])
  @@map("clusters")
}

enum CloudProvider {
  AWS
  GCP
  AZURE
  ON_PREM
  OTHER
}

enum Environment {
  PRODUCTION
  STAGING
  DEVELOPMENT
  TESTING
}

enum ClusterStatus {
  PENDING     // Just added, not yet connected
  CONNECTED   // Successfully connected
  DEGRADED    // Connected but with issues
  DISCONNECTED // Lost connection
  ERROR       // Connection error
}

enum AuthMethod {
  TOKEN       // Service account token
  CERTIFICATE // Client certificate
  OIDC        // OpenID Connect
  AWS_IAM     // AWS IAM authentication
  GCP_WIF     // GCP Workload Identity
  AZURE_AD    // Azure Active Directory
}

// ============================================================================
// POLICIES
// ============================================================================

model Policy {
  id          String      @id @default(cuid())
  name        String
  description String?
  type        PolicyType
  status      PolicyStatus @default(DRAFT)
  
  // The actual policy YAML/JSON
  content     String       @db.Text
  
  // AI-generated policies track their source
  generatedFrom   String?  @db.Text // Original natural language prompt
  generatedModel  String?            // AI model used (e.g., "claude-3-sonnet")
  
  // Targeting
  targetNamespaces String[] // Empty = all namespaces
  targetLabels     Json?    // Label selectors as JSON
  
  // Deployment tracking
  deployedAt      DateTime?
  deployedVersion Int?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Multi-tenancy
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  // Cluster association
  clusterId String
  cluster   Cluster @relation(fields: [clusterId], references: [id], onDelete: Cascade)

  // Template association (optional - for multi-cluster sync)
  templateId        String?
  template          PolicyTemplate? @relation(fields: [templateId], references: [id], onDelete: SetNull)
  syncedFromVersion Int? // Which template version this policy was synced from

  // Creator tracking
  createdById String
  createdBy   User @relation("PolicyCreator", fields: [createdById], references: [id])

  // Relationships
  versions    PolicyVersion[]
  simulations Simulation[]
  deployments PolicyDeployment[]

  @@unique([clusterId, name])
  @@index([templateId])
  @@index([organizationId, status])
  @@map("policies")
}

enum PolicyType {
  CILIUM_NETWORK     // CiliumNetworkPolicy
  CILIUM_CLUSTERWIDE // CiliumClusterwideNetworkPolicy
  TETRAGON           // TracingPolicy
  GATEWAY_HTTPROUTE  // HTTPRoute
  GATEWAY_GRPCROUTE  // GRPCRoute
  GATEWAY_TCPROUTE   // TCPRoute
  GATEWAY_TLSROUTE   // TLSRoute
}

enum PolicyStatus {
  DRAFT       // Not yet deployed
  SIMULATING  // Running in simulation
  PENDING     // Queued for deployment
  DEPLOYED    // Active in cluster
  UNDEPLOYING // Being removed from cluster
  FAILED      // Deployment failed
  ARCHIVED    // No longer active
}

model PolicyVersion {
  id        String   @id @default(cuid())
  version   Int
  content   String   @db.Text
  changelog String?
  createdAt DateTime @default(now())

  // Parent policy
  policyId String
  policy   Policy @relation(fields: [policyId], references: [id], onDelete: Cascade)

  // Deployments of this version
  deployments PolicyDeployment[]

  @@unique([policyId, version])
  @@map("policy_versions")
}

// Track deployment history for policies
model PolicyDeployment {
  id          String   @id @default(cuid())

  // What was deployed
  policyId    String
  policy      Policy   @relation(fields: [policyId], references: [id], onDelete: Cascade)

  versionId   String
  version     PolicyVersion @relation(fields: [versionId], references: [id], onDelete: Cascade)

  // Where it was deployed
  clusterId   String
  cluster     Cluster  @relation(fields: [clusterId], references: [id], onDelete: Cascade)

  // Deployment status
  status      DeploymentStatus @default(PENDING)

  // Kubernetes resource info (after deployment)
  resourceName      String?   // Name of created K8s resource
  resourceNamespace String?   // Namespace (if applicable)
  resourceVersion   String?   // K8s resourceVersion for conflict detection

  // Who triggered the deployment
  deployedById String
  deployedBy   User @relation("DeploymentActor", fields: [deployedById], references: [id])

  // Rollback tracking
  previousDeploymentId String?
  previousDeployment   PolicyDeployment? @relation("RollbackChain", fields: [previousDeploymentId], references: [id])
  rollbackDeployments  PolicyDeployment[] @relation("RollbackChain")

  isRollback    Boolean  @default(false)
  rollbackNote  String?

  // Error tracking
  errorMessage  String?  @db.Text
  errorDetails  Json?

  // Retry tracking
  retryCount    Int      @default(0)
  maxRetries    Int      @default(3)
  lastRetryAt   DateTime?

  // Timestamps
  requestedAt   DateTime @default(now())
  startedAt     DateTime?
  completedAt   DateTime?

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([policyId, requestedAt])
  @@index([clusterId, requestedAt])
  @@index([status])
  @@map("policy_deployments")
}

enum DeploymentStatus {
  PENDING     // Queued for deployment
  IN_PROGRESS // Being applied to cluster
  SUCCEEDED   // Successfully deployed
  FAILED      // Deployment failed
  ROLLED_BACK // Was rolled back
  UNDEPLOYING // Being removed from cluster
  UNDEPLOYED  // Successfully removed from cluster
}

// ============================================================================
// POLICY TEMPLATES (Multi-Cluster Sync)
// ============================================================================

model PolicyTemplate {
  id                      String   @id @default(cuid())
  name                    String
  description             String?
  type                    PolicyType
  content                 String   @db.Text

  // Default targeting (can be overridden per-cluster during sync)
  defaultTargetNamespaces String[]
  defaultTargetLabels     Json?

  // Versioning
  currentVersion Int @default(1)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Multi-tenancy (org-level, no clusterId)
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  // Creator tracking
  createdById String
  createdBy   User @relation("TemplateCreator", fields: [createdById], references: [id])

  // Relationships
  versions       PolicyTemplateVersion[]
  policies       Policy[]                // Policies instantiated from this template
  syncOperations TemplateSyncOperation[] // History of sync operations

  @@unique([organizationId, name])
  @@map("policy_templates")
}

model PolicyTemplateVersion {
  id        String   @id @default(cuid())
  version   Int
  content   String   @db.Text
  changelog String?
  createdAt DateTime @default(now())

  // Parent template
  templateId String
  template   PolicyTemplate @relation(fields: [templateId], references: [id], onDelete: Cascade)

  @@unique([templateId, version])
  @@map("policy_template_versions")
}

// Track sync operations for audit trail
model TemplateSyncOperation {
  id         String         @id @default(cuid())
  templateId String
  template   PolicyTemplate @relation(fields: [templateId], references: [id], onDelete: Cascade)

  // Which version was synced
  templateVersion Int

  // Which clusters were targeted
  targetClusterIds String[]

  // Results
  status          SyncOperationStatus @default(PENDING)
  policiesCreated Int                 @default(0)
  policiesUpdated Int                 @default(0)
  policiesFailed  Int                 @default(0)
  errorDetails    Json? // Array of {clusterId, error} for failures

  // Who triggered
  triggeredById String
  triggeredBy   User @relation("SyncTrigger", fields: [triggeredById], references: [id])

  createdAt   DateTime  @default(now())
  completedAt DateTime?

  @@index([templateId, createdAt])
  @@map("template_sync_operations")
}

enum SyncOperationStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  COMPLETED_WITH_ERRORS
  FAILED
}

// ============================================================================
// ENFORCEMENT VALIDATION
// ============================================================================

// Validation verdicts aggregated hourly
model ValidationSummary {
  id          String   @id @default(cuid())
  clusterId   String
  cluster     Cluster  @relation(fields: [clusterId], references: [id], onDelete: Cascade)

  hour        DateTime // Bucket timestamp (start of hour)

  // Verdict counts
  allowedCount   Int @default(0)
  blockedCount   Int @default(0)
  noPolicyCount  Int @default(0)

  // Top sources/destinations with NO_POLICY (coverage gaps)
  coverageGaps   Json?  // Array of {srcNamespace, srcPodName, dstNamespace, dstPodName, dstPort, count}

  // Top blocked flows (potential misconfigurations)
  topBlocked     Json?  // Array of {srcNamespace, srcPodName, dstNamespace, dstPodName, policy, count}

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([clusterId, hour])
  @@index([clusterId, hour])
  @@map("validation_summaries")
}

// Individual validation events (kept short-term for debugging)
model ValidationEvent {
  id          String   @id @default(cuid())
  clusterId   String
  cluster     Cluster  @relation(fields: [clusterId], references: [id], onDelete: Cascade)

  timestamp   DateTime
  verdict     ValidationVerdict

  srcNamespace  String
  srcPodName    String?
  srcLabels     Json?

  dstNamespace  String
  dstPodName    String?
  dstLabels     Json?
  dstPort       Int
  protocol      String

  matchedPolicy String?  // Policy name if applicable
  reason        String?  // Human-readable explanation

  createdAt   DateTime @default(now())

  @@index([clusterId, timestamp])
  @@index([clusterId, verdict])
  @@index([timestamp]) // For TTL cleanup
  @@index([clusterId, timestamp, verdict])
  @@map("validation_events")
}

enum ValidationVerdict {
  ALLOWED    // Explicitly allowed by policy
  BLOCKED    // Blocked (policy exists, no match)
  NO_POLICY  // No policy governs this flow
}

// ============================================================================
// POLICY PACK MARKETPLACE
// ============================================================================

// Policy pack definition
model PolicyPack {
  id          String   @id @default(cuid())
  slug        String   @unique  // e.g., "soc2-network-controls"
  name        String
  description String   @db.Text

  tier        PolicyPackTier
  category    PolicyPackCategory

  // For enterprise packs
  complianceFramework String?    // "SOC2", "DORA", "PCI-DSS", "CIS"
  auditorName         String?    // Third-party auditor
  certificationDate   DateTime?

  // Content
  version     String
  policies    PolicyPackItem[]

  // Metadata
  iconUrl     String?
  docsUrl     String?
  tags        String[]

  isPublished Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Created by organization (for user-created packs)
  createdByOrgId String?
  createdByOrg   Organization? @relation("OrgCreatedPacks", fields: [createdByOrgId], references: [id])

  // Usage tracking
  installations PolicyPackInstallation[]

  @@index([createdByOrgId])
  @@map("policy_packs")
}

enum PolicyPackTier {
  COMMUNITY   // Free, community-reviewed
  ENTERPRISE  // Paid, auditor-certified
}

enum PolicyPackCategory {
  COMPLIANCE  // SOC2, DORA, PCI-DSS, CIS
  WORKLOAD    // Microservices, databases, etc.
  SECURITY    // General security patterns
}

// Individual policy within a pack
model PolicyPackItem {
  id          String     @id @default(cuid())
  packId      String
  pack        PolicyPack @relation(fields: [packId], references: [id], onDelete: Cascade)

  name        String
  description String     @db.Text
  policyType  PolicyType
  yamlContent String     @db.Text

  // For enterprise: control mapping
  controlIds  Json?      // e.g., ["CC6.1.1", "CC6.1.2"] for SOC2

  order       Int        @default(0)

  createdAt   DateTime   @default(now())

  @@index([packId])
  @@map("policy_pack_items")
}

// Track pack installations per organization
model PolicyPackInstallation {
  id             String       @id @default(cuid())
  packId         String
  pack           PolicyPack   @relation(fields: [packId], references: [id], onDelete: Cascade)
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  installedAt    DateTime     @default(now())
  installedById  String
  installedBy    User         @relation("PackInstaller", fields: [installedById], references: [id])

  // Which clusters have this pack deployed
  deployments    PolicyPackDeployment[]

  @@unique([packId, organizationId])
  @@index([organizationId])
  @@map("policy_pack_installations")
}

// Track pack deployment to specific clusters
model PolicyPackDeployment {
  id              String   @id @default(cuid())
  installationId  String
  installation    PolicyPackInstallation @relation(fields: [installationId], references: [id], onDelete: Cascade)
  clusterId       String
  cluster         Cluster  @relation(fields: [clusterId], references: [id], onDelete: Cascade)

  status          PackDeploymentStatus @default(PENDING)
  deployedAt      DateTime?
  errorMessage    String?

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([installationId, clusterId])
  @@index([clusterId])
  @@map("policy_pack_deployments")
}

enum PackDeploymentStatus {
  PENDING
  DEPLOYING
  DEPLOYED
  FAILED
}

// Organization subscription for enterprise features
model Subscription {
  id             String       @id @default(cuid())
  organizationId String       @unique
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  tier           SubscriptionTier   @default(FREE)
  status         SubscriptionStatus @default(ACTIVE)

  // Stripe integration (optional)
  stripeCustomerId     String?
  stripeSubscriptionId String?

  currentPeriodStart DateTime?
  currentPeriodEnd   DateTime?

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("subscriptions")
}

enum SubscriptionTier {
  FREE
  ENTERPRISE
}

enum SubscriptionStatus {
  ACTIVE
  CANCELLED
  PAST_DUE
  TRIALING
}

// ============================================================================
// FLOW RECORDS (Traffic Data for Simulation)
// ============================================================================

model FlowRecord {
  id        String   @id @default(cuid())
  timestamp DateTime

  // Source
  srcNamespace String
  srcPodName   String?
  srcPodLabels Json?
  srcIP        String
  srcPort      Int?

  // Destination
  dstNamespace String
  dstPodName   String?
  dstPodLabels Json?
  dstIP        String
  dstPort      Int

  // Protocol info
  protocol   String // TCP, UDP, ICMP
  l7Protocol String? // HTTP, gRPC, DNS, Kafka

  // HTTP-specific (if l7Protocol = HTTP)
  httpMethod String?
  httpPath   String?
  httpStatus Int?

  // Verdict from current policy
  verdict FlowVerdict
  
  // Traffic volume
  bytesTotal   BigInt?
  packetsTotal BigInt?

  // Cluster association
  clusterId String
  cluster   Cluster @relation(fields: [clusterId], references: [id], onDelete: Cascade)

  // Indexing for time-range queries
  @@index([clusterId, timestamp])
  @@index([srcNamespace, dstNamespace])
  @@map("flow_records")
}

enum FlowVerdict {
  ALLOWED
  DENIED
  AUDIT   // Would be denied but in audit mode
  UNKNOWN
}

// ============================================================================
// SIMULATIONS (Time-Travel Feature)
// ============================================================================

model Simulation {
  id          String           @id @default(cuid())
  name        String
  description String?
  status      SimulationStatus @default(PENDING)

  // Time range for traffic replay
  startTime DateTime
  endTime   DateTime

  // Multi-node aggregation tracking
  expectedNodes   Int?      // Number of collector nodes in cluster
  processedNodes  Json?     // Array of node names that have submitted results
  nodeResults     Json?     // Object mapping node name to partial results
  aggregationDeadline DateTime? // When to finalize even if not all nodes responded

  // Aggregated Results
  flowsAnalyzed   Int?
  flowsAllowed    Int?
  flowsDenied     Int?
  flowsChanged    Int? // Flows that would have different verdict
  completedAt     DateTime?

  // Detailed results stored as JSON
  results Json?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Associations
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  clusterId String
  cluster   Cluster @relation(fields: [clusterId], references: [id], onDelete: Cascade)

  policyId String
  policy   Policy @relation(fields: [policyId], references: [id], onDelete: Cascade)

  runnerId String
  runner   User @relation("SimulationRunner", fields: [runnerId], references: [id])

  @@map("simulations")
}

enum SimulationStatus {
  PENDING    // Queued
  RUNNING    // In progress
  COMPLETED  // Finished successfully
  FAILED     // Error during simulation
  CANCELLED  // User cancelled
}

// ============================================================================
// AUDIT LOG
// ============================================================================

model AuditLog {
  id        String   @id @default(cuid())
  timestamp DateTime @default(now())

  action       String    // e.g., "user.login", "policy.created", "cluster.connected"
  resource     String?   // Legacy field (kept for compatibility)
  resourceType String?   // e.g., "Policy", "Cluster", "User"
  resourceId   String?

  userId    String?
  user      User?    @relation("AuditUser", fields: [userId], references: [id])
  userEmail String?

  organizationId String?
  organization   Organization? @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  clusterId String?
  cluster   Cluster? @relation(fields: [clusterId], references: [id], onDelete: SetNull)

  details   Json?     // Additional context
  ipAddress String?
  userAgent String?

  @@index([organizationId, timestamp])
  @@index([userId, timestamp])
  @@index([action, timestamp])
  @@index([clusterId])
  @@map("audit_logs")
}

// ============================================================================
// API TOKENS (for Operator Authentication)
// ============================================================================

model ApiToken {
  id          String      @id @default(cuid())
  name        String
  type        TokenType   @default(AGENT)
  tokenHash   String      @unique  // SHA-256 hash of the actual token
  prefix      String               // First 8 chars for identification (e.g., "kph_at_xxx")
  scopes      String[]             // ["cluster:read", "cluster:write", "policy:read", "flow:write"]

  status      TokenStatus @default(ACTIVE)
  expiresAt   DateTime?
  lastUsedAt  DateTime?
  revokedAt   DateTime?
  createdAt   DateTime    @default(now())

  // Links to cluster for cluster-scoped tokens
  clusterId      String?
  cluster        Cluster?  @relation(fields: [clusterId], references: [id], onDelete: Cascade)

  // Multi-tenancy
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  // Creator tracking
  createdById    String?
  createdBy      User?     @relation("TokenCreator", fields: [createdById], references: [id])

  @@index([tokenHash])
  @@index([clusterId])
  @@index([status])
  @@map("api_tokens")
}

// ============================================================================
// TELEMETRY AGGREGATES (From Operator)
// ============================================================================

model FlowSummary {
  id              String   @id @default(cuid())
  clusterId       String
  timestamp       DateTime
  windowStart     DateTime
  windowEnd       DateTime
  nodeName        String
  srcNamespace    String
  dstNamespace    String
  srcPodName      String?
  dstPodName      String?
  dstPort         Int
  protocol        String
  l7Type          String?
  totalFlows      BigInt
  allowedFlows    BigInt
  deniedFlows     BigInt
  droppedFlows    BigInt
  totalBytes      BigInt
  totalPackets    BigInt
  httpMethodCounts Json?   // Record<string, number>
  httpStatusCounts Json?   // Record<number, number>
  topHttpPaths     Json?   // Array<{path, count}>
  topDnsQueries    Json?   // Array<{query, count}>
  createdAt       DateTime @default(now())

  cluster         Cluster  @relation(fields: [clusterId], references: [id], onDelete: Cascade)

  @@index([clusterId, timestamp])
  @@index([clusterId, srcNamespace, dstNamespace])
  @@index([windowStart, windowEnd])
  @@index([clusterId, timestamp, srcNamespace, dstNamespace])
  @@map("flow_summaries")
}

model ProcessSummary {
  id              String   @id @default(cuid())
  clusterId       String
  timestamp       DateTime
  windowStart     DateTime
  windowEnd       DateTime
  nodeName        String
  namespace       String
  podName         String
  processName     String
  execCount       Int
  syscallCounts   Json?    // Record<string, number>
  createdAt       DateTime @default(now())

  cluster         Cluster  @relation(fields: [clusterId], references: [id], onDelete: Cascade)

  @@index([clusterId, timestamp])
  @@index([clusterId, namespace])
  @@map("process_summaries")
}

// ============================================================================
// POLICY SIMULATIONS (Operator-Initiated)
// ============================================================================

model PolicySimulation {
  id                    String    @id @default(cuid())
  clusterId             String
  policyContent         String    @db.Text
  policyType            String    // CILIUM_NETWORK, CILIUM_CLUSTERWIDE, etc.
  status                String    @default("PENDING") // PENDING, IN_PROGRESS, COMPLETED, COMPLETED_WITH_ERRORS, FAILED

  // Query parameters
  startTime             DateTime
  endTime               DateTime
  namespaces            Json?     // string[]
  includeDetails        Boolean   @default(false)
  maxDetails            Int       @default(100)

  // Results
  totalFlowsAnalyzed    BigInt?
  allowedCount          BigInt?
  deniedCount           BigInt?
  noChangeCount         BigInt?
  wouldChangeCount      BigInt?
  breakdownByNamespace  Json?     // Record<string, NSImpact>
  breakdownByVerdict    Json?     // VerdictBreakdown
  sampleFlows           Json?     // SimulatedFlow[]
  errors                Json?     // string[]
  durationNs            BigInt?   // Duration in nanoseconds

  // Timestamps
  requestedAt           DateTime  @default(now())
  startedAt             DateTime?
  completedAt           DateTime?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  cluster               Cluster   @relation(fields: [clusterId], references: [id], onDelete: Cascade)

  @@index([clusterId, status])
  @@index([clusterId, requestedAt])
  @@index([status])
  @@map("policy_simulations")
}

// ============================================================================
// NOTIFICATIONS (For UI Alerts)
// ============================================================================

model Notification {
  id          String   @id @default(cuid())
  clusterId   String
  type        String   // SIMULATION_COMPLETE, POLICY_DEPLOYED, etc.
  title       String
  message     String
  metadata    Json?
  read        Boolean  @default(false)
  createdAt   DateTime @default(now())

  cluster     Cluster  @relation(fields: [clusterId], references: [id], onDelete: Cascade)

  @@index([clusterId, read])
  @@index([clusterId, createdAt])
  @@map("notifications")
}

// ============================================================================
// PROCESS VALIDATION (Tetragon Enforcement Tracking)
// ============================================================================

// Process validation verdicts aggregated hourly
model ProcessValidationSummary {
  id          String   @id @default(cuid())
  clusterId   String
  cluster     Cluster  @relation(fields: [clusterId], references: [id], onDelete: Cascade)

  hour        DateTime // Bucket timestamp (start of hour)

  // Verdict counts
  allowedCount   Int @default(0)  // Processes allowed to execute
  blockedCount   Int @default(0)  // Processes blocked by TracingPolicy (SIGKILL/OVERRIDE)
  noPolicyCount  Int @default(0)  // Processes with no governing TracingPolicy

  // Top blocked processes (potential security events)
  topBlocked     Json?  // Array of {namespace, podName, binary, policy, count}

  // Coverage gaps (processes not covered by any policy)
  coverageGaps   Json?  // Array of {namespace, podName, binary, count}

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([clusterId, hour])
  @@index([clusterId, hour])
  @@map("process_validation_summaries")
}

// Individual process validation events (kept short-term for debugging)
model ProcessValidationEvent {
  id          String   @id @default(cuid())
  clusterId   String
  cluster     Cluster  @relation(fields: [clusterId], references: [id], onDelete: Cascade)

  timestamp   DateTime
  verdict     ProcessValidationVerdict

  // Process context
  namespace     String
  podName       String?
  nodeName      String?
  binary        String    // Full path: /bin/bash, /usr/bin/curl
  arguments     String?   // Command line arguments (truncated)
  parentBinary  String?   // Parent process binary

  // Syscall context (if kprobe event)
  syscall       String?
  filePath      String?

  // Policy match info
  matchedPolicy String?   // TracingPolicy name if applicable
  action        String?   // SIGKILL, OVERRIDE, POST (allowed)
  reason        String?   // Human-readable explanation

  createdAt   DateTime @default(now())

  @@index([clusterId, timestamp])
  @@index([clusterId, verdict])
  @@index([timestamp]) // For TTL cleanup
  @@index([clusterId, timestamp, verdict])
  @@map("process_validation_events")
}

enum ProcessValidationVerdict {
  ALLOWED    // Process executed normally
  BLOCKED    // Process killed by TracingPolicy (SIGKILL/OVERRIDE)
  NO_POLICY  // No TracingPolicy governs this process
}
